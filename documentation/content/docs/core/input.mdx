---
title: Input
description: API reference for the input system
---

import { TypeTable } from 'fumadocs-ui/components/type-table';
import { Terminal } from '@/components/terminal';
import FileListExample from '@/components/examples/input/file-list';
import FocusTrapExample from '@/components/examples/input/focus-trap';

The input system routes keyboard events to the focused component and its ancestors.

Register handlers with `useKeybindings` — when a key is pressed, the focused component's bindings are checked first, then its parent's, and so on. The first matching binding wins; unmatched keys keep moving up. Components outside the focused path never receive input.

For modal-like scenarios, `FocusTrap` locks input inside a subtree — nothing outside it is reachable until the trap unmounts.

```tsx title="Basic Usage"
import { useKeybindings, useFocus } from 'giggles';
import { useState } from 'react';
import { Box, Text } from 'ink';

function FileList() {
  const focus = useFocus();
  const [selected, setSelected] = useState(0);
  const files = ['file1.ts', 'file2.ts', 'file3.ts'];

  useKeybindings(focus, {
    j: () => setSelected((i) => Math.min(files.length - 1, i + 1)),
    k: () => setSelected((i) => Math.max(0, i - 1)),
  });

  return (
    <Box flexDirection="column">
      {files.map((file, i) => (
        <Text key={file} color={i === selected ? 'green' : 'white'}>
          {i === selected ? '> ' : '  '}
          {file}
        </Text>
      ))}
    </Box>
  );
}
```

## API Reference

### useKeybindings()

Registers keybindings that only fire when the component is focused.

```ts title="Type Signature"
function useKeybindings(
  focus: { id: string },
  bindings: Keybindings,
  options?: KeybindingOptions
): void
```

**Parameters:**

<TypeTable
  type={{
    focus: {
      description: 'Focus handle from useFocus()',
      type: '{ id: string }',
      required: true,
    },
    bindings: {
      description: 'Map of key names to handler functions',
      type: 'Keybindings',
      required: true,
    },
    options: {
      description: 'Optional configuration for capture mode and layers',
      type: 'KeybindingOptions',
    },
  }}
/>

#### KeyHandler

Handler function for a key binding.

```ts title="Type Signature"
type KeyHandler = (input: string, key: Key) => void
```

<TypeTable
  type={{
    input: {
      description: 'The character string for the key pressed',
      type: 'string',
      required: true,
    },
    key: {
      description: 'Ink Key object with boolean properties (downArrow, return, escape, etc.)',
      type: 'Key',
      required: true,
    },
  }}
/>

#### Keybindings

Each value can be a plain handler function or a named binding object. Named bindings are registered in the command registry and become discoverable via `useKeybindingRegistry`.

<TypeTable
  type={{
    '[key: string]': {
      description: 'Key name mapped to a handler function or named binding object. See Key Names below for valid key strings.',
      type: 'KeyHandler | { action: KeyHandler; name: string; when?: "focused" | "mounted" }',
    },
  }}
/>

The `when` field controls when the binding is considered available:
- `"focused"` (default) — active only when the registering component is the focused leaf
- `"mounted"` — active whenever the component is mounted, regardless of focus. Fires even if the component is not in the current focus path.

#### Key Names

Use these strings as keys in the bindings object:

| Key string | Triggers on |
|---|---|
| `up`, `down`, `left`, `right` | Arrow keys |
| `enter` | Return / Enter |
| `escape` | Escape |
| `tab` | Tab |
| `shift+tab` | Shift + Tab |
| `backspace` | Backspace or Delete (⌫) |
| `delete` | Forward delete (⌦) |
| `pageup`, `pagedown` | Page Up / Page Down |
| `home`, `end` | Home / End |
| `ctrl+c`, `ctrl+q`, … | Ctrl + any letter |
| `a`, `j`, `?`, … | Any printable character |

#### KeybindingOptions

Capture mode intercepts all input at the component, preventing it from bubbling to parents. Named bindings are still checked first — any key matching a named binding fires that handler. Remaining keys fall through to `onKeypress`. Use `passthrough` to let specific keys bypass capture and continue bubbling to parent nodes.

<TypeTable
  type={{
    capture: {
      description: 'When enabled, unmatched keystrokes go to onKeypress instead of being handled by parent components',
      type: 'boolean',
      default: 'false',
    },
    onKeypress: {
      description: 'Handler for keystrokes in capture mode that don\'t match named bindings',
      type: '(input: string, key: Key) => void',
    },
    passthrough: {
      description: 'Key names that bypass capture mode and are handled by parent components instead. Useful for letting keys like escape reach parent components.',
      type: 'string[]',
    },
    layer: {
      description: 'Optional layer identifier for organizing keybindings (metadata only)',
      type: 'string',
    },
  }}
/>

### useKeybindingRegistry()

Reads all named keybindings registered across the app. Useful for building command palettes, help screens, and key hints bars.

```tsx title="Help Screen"
import { useKeybindingRegistry } from 'giggles';
import { Box, Text } from 'ink';

function HelpScreen() {
  const registry = useKeybindingRegistry();

  return (
    <Box flexDirection="column">
      {registry.available.map((cmd) => (
        <Box key={`${cmd.nodeId}-${cmd.key}`} gap={2}>
          <Text color="cyan">{cmd.key}</Text>
          <Text>{cmd.name}</Text>
        </Box>
      ))}
    </Box>
  );
}
```

<TypeTable
  type={{
    all: {
      description: 'All named bindings registered across the entire app',
      type: 'RegisteredKeybinding[]',
      required: true,
    },
    available: {
      description: 'Named bindings currently reachable — focused/ancestor bindings from the active focus path, plus all mounted bindings',
      type: 'RegisteredKeybinding[]',
      required: true,
    },
    local: {
      description: 'Named bindings registered by the component that passed its focus handle. Empty if no focus handle provided.',
      type: 'RegisteredKeybinding[]',
      required: true,
    },
  }}
/>

#### RegisteredKeybinding

<TypeTable
  type={{
    nodeId: {
      description: 'Focus node ID of the registering component',
      type: 'string',
      required: true,
    },
    key: {
      description: 'The key name the binding is registered under',
      type: 'string',
      required: true,
    },
    handler: {
      description: 'The handler function',
      type: 'KeyHandler',
      required: true,
    },
    name: {
      description: 'Human-readable label (only present on named bindings)',
      type: 'string | undefined',
    },
    when: {
      description: 'Availability scope of the binding',
      type: '"focused" | "mounted" | undefined',
    },
  }}
/>

### FocusTrap

Isolates input within a boundary. When mounted, it captures focus into its subtree and prevents input from reaching components outside. When unmounted, it restores focus to the previously focused component.

```tsx title="FocusTrap Example"
function App() {
  const [showModal, setShowModal] = useState(false);

  return (
    <>
      <MainContent />
      {showModal && (
        <FocusTrap>
          <Modal onClose={() => setShowModal(false)} />
        </FocusTrap>
      )}
    </>
  );
}
```

<TypeTable
  type={{
    children: {
      description: 'Components that should trap input',
      type: 'React.ReactNode',
      required: true,
    },
  }}
/>

## Examples

### File list

```tsx title="File List"
import { useFocus, useKeybindings } from 'giggles';
import { useState } from 'react';
import { Box, Text } from 'ink';

function FileList() {
  const focus = useFocus();
  const [selected, setSelected] = useState(0);
  const files = ['file1.ts', 'file2.ts', 'file3.ts'];

  useKeybindings(focus, {
    j: () => setSelected((i) => Math.min(files.length - 1, i + 1)),
    k: () => setSelected((i) => Math.max(0, i - 1)),
  });

  return (
    <Box flexDirection="column">
      {files.map((file, i) => (
        <Text key={file} color={i === selected ? 'green' : 'white'}>
          {i === selected ? '> ' : '  '}{file}
        </Text>
      ))}
    </Box>
  );
}
```

<Terminal>
  <FileListExample />
</Terminal>

### Focus trap

When a `FocusTrap` is active, input stops bubbling past it. The menu behind the modal won't receive any keypresses:

```tsx title="Modal with FocusTrap"
import { FocusGroup, FocusTrap, useFocus, useKeybindings } from 'giggles';
import { Box, Text } from 'ink';
import { useState } from 'react';

function App() {
  const [showModal, setShowModal] = useState(false);

  return (
    <Box flexDirection="column">
      <FocusGroup keybindings={({ next, prev }) => ({ up: prev, down: next, k: prev, j: next, m: () => setShowModal(true) })}>
        <MenuItem label="New File" />
        <MenuItem label="Open File" />
        <MenuItem label="Save" />
      </FocusGroup>
      {showModal && (
        <FocusTrap>
          <Modal onClose={() => setShowModal(false)} />
        </FocusTrap>
      )}
    </Box>
  );
}
```

<Terminal>
  <FocusTrapExample />
</Terminal>
