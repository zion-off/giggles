---
title: Input
description: API reference for the input system
---

import { TypeTable } from 'fumadocs-ui/components/type-table';
import { Terminal } from '@/components/terminal';
import FileListExample from '@/components/examples/input/file-list';
import FocusTrapExample from '@/components/examples/input/focus-trap';

The input system routes keyboard events to focused components and prevents input leaking.

Key events are dispatched along the active branch of the focus tree — from the focused node upward to the root. Each node on the path can register keybindings with `useKeybindings`, and the first matching binding handles the event. This means a focused child's bindings take priority over its parent's, and components outside the active branch never receive input.

For modal-like scenarios where input should be isolated, `FocusTrap` stops events from bubbling past a boundary.

```tsx title="Basic Usage"
import { useKeybindings, useFocus } from 'giggles';
import { useState } from 'react';
import { Box, Text } from 'ink';

function FileList() {
  const focus = useFocus();
  const [selected, setSelected] = useState(0);
  const files = ['file1.ts', 'file2.ts', 'file3.ts'];

  useKeybindings(focus, {
    j: () => setSelected((i) => Math.min(files.length - 1, i + 1)),
    k: () => setSelected((i) => Math.max(0, i - 1)),
  });

  return (
    <Box flexDirection="column">
      {files.map((file, i) => (
        <Text key={file} color={i === selected ? 'green' : 'white'}>
          {i === selected ? '> ' : '  '}
          {file}
        </Text>
      ))}
    </Box>
  );
}
```

## API Reference

### useKeybindings()

Registers keybindings that only fire when the component is focused.

```ts title="Type Signature"
function useKeybindings(
  focus: { id: string },
  bindings: Keybindings,
  options?: KeybindingOptions
): void
```

**Parameters:**

<TypeTable
  type={{
    focus: {
      description: 'Focus handle from useFocus()',
      type: '{ id: string }',
    },
    bindings: {
      description: 'Map of key names to handler functions',
      type: 'Keybindings',
    },
    options: {
      description: 'Optional configuration for capture mode and layers',
      type: 'KeybindingOptions',
    },
  }}
/>

#### KeyHandler

Handler function for a key binding.

```ts title="Type Signature"
type KeyHandler = (input: string, key: Key) => void
```

<TypeTable
  type={{
    input: {
      description: 'The character string for the key pressed',
      type: 'string',
    },
    key: {
      description: 'Ink Key object with boolean properties (downArrow, return, escape, etc.)',
      type: 'Key',
    },
  }}
/>

#### Keybindings

Each value can be a plain handler function or a named binding object. Named bindings are registered in the command registry and become discoverable via `useKeybindingRegistry`.

<TypeTable
  type={{
    '[key: string]': {
      description: 'Key name mapped to a handler function or named binding object',
      type: 'KeyHandler | { action: KeyHandler; name: string; when?: "focused" | "mounted" }',
    },
  }}
/>

The `when` field controls when the binding is considered available:
- `"focused"` (default) — active only when the registering component is the focused leaf
- `"mounted"` — active whenever the component is mounted, regardless of focus. Fires even if the component is not in the current focus path.

#### KeybindingOptions

Capture mode intercepts all input at the component, preventing it from bubbling to parents. Named bindings are still checked first — any key matching a named binding fires that handler. Remaining keys fall through to `onKeypress`. Use `passthrough` to let specific keys bypass capture and continue bubbling to parent nodes.

<TypeTable
  type={{
    capture: {
      description: 'Enable capture mode — unmatched keystrokes go to onKeypress instead of bubbling',
      type: 'boolean',
      default: 'false',
    },
    onKeypress: {
      description: 'Handler for keystrokes in capture mode that don\'t match named bindings',
      type: '(input: string, key: Key) => void',
    },
    passthrough: {
      description: 'Key names that should skip capture and continue bubbling to parent nodes. Useful for letting keys like escape reach parent components.',
      type: 'string[]',
    },
    layer: {
      description: 'Optional layer identifier for organizing keybindings (metadata only)',
      type: 'string',
    },
  }}
/>

### useKeybindingRegistry()

Reads all named keybindings registered across the app. Useful for building command palettes, help screens, and key hints bars.

```tsx title="Help Screen"
import { useKeybindingRegistry } from 'giggles';
import { Box, Text } from 'ink';

function HelpScreen() {
  const registry = useKeybindingRegistry();

  return (
    <Box flexDirection="column">
      {registry.available.map((cmd) => (
        <Box key={`${cmd.nodeId}-${cmd.key}`} gap={2}>
          <Text color="cyan">{cmd.key}</Text>
          <Text>{cmd.name}</Text>
        </Box>
      ))}
    </Box>
  );
}
```

<TypeTable
  type={{
    all: {
      description: 'All named bindings registered across the entire app',
      type: 'RegisteredKeybinding[]',
    },
    available: {
      description: 'Named bindings currently reachable — focused/ancestor bindings from the active focus path, plus all mounted bindings',
      type: 'RegisteredKeybinding[]',
    },
    local: {
      description: 'Named bindings registered by the component that passed its focus handle. Empty if no focus handle provided.',
      type: 'RegisteredKeybinding[]',
    },
  }}
/>

#### RegisteredKeybinding

<TypeTable
  type={{
    nodeId: {
      description: 'Internal focus node ID of the registering component',
      type: 'string',
    },
    key: {
      description: 'The key name the binding is registered under',
      type: 'string',
    },
    handler: {
      description: 'The handler function',
      type: 'KeyHandler',
    },
    name: {
      description: 'Human-readable label (only present on named bindings)',
      type: 'string | undefined',
    },
    when: {
      description: 'Availability scope of the binding',
      type: '"focused" | "mounted" | undefined',
    },
  }}
/>

### FocusTrap

Isolates input within a boundary. When mounted, it captures focus into its subtree and prevents input from reaching components outside. When unmounted, it restores focus to the previously focused component.

```tsx title="FocusTrap Example"
function App() {
  const [showModal, setShowModal] = useState(false);

  return (
    <>
      <MainContent />
      {showModal && (
        <FocusTrap>
          <Modal onClose={() => setShowModal(false)} />
        </FocusTrap>
      )}
    </>
  );
}
```

<TypeTable
  type={{
    children: {
      description: 'Components that should trap input',
      type: 'React.ReactNode',
    },
  }}
/>

### Key Names

Supported key names for bindings:

- **Special keys**: `enter`, `escape`, `tab`, `backspace`, `up`, `down`, `left`, `right`, `pageup`, `pagedown`, `home`, `end`
- **Character keys**: `a`, `b`, `j`, `k`, `?`, etc.
- **Modified keys**: `ctrl+c`, `ctrl+q`, etc.

Key normalization handles variants like `ctrl+c`, `Ctrl-C`, `^c` automatically.

## Examples

### File list

```tsx title="File List"
import { useFocus, useKeybindings } from 'giggles';
import { useState } from 'react';
import { Box, Text } from 'ink';

function FileList() {
  const focus = useFocus();
  const [selected, setSelected] = useState(0);
  const files = ['file1.ts', 'file2.ts', 'file3.ts'];

  useKeybindings(focus, {
    j: () => setSelected((i) => Math.min(files.length - 1, i + 1)),
    k: () => setSelected((i) => Math.max(0, i - 1)),
  });

  return (
    <Box flexDirection="column">
      {files.map((file, i) => (
        <Text key={file} color={i === selected ? 'green' : 'white'}>
          {i === selected ? '> ' : '  '}{file}
        </Text>
      ))}
    </Box>
  );
}
```

<Terminal>
  <FileListExample />
</Terminal>

### Focus trap

When a `FocusTrap` is active, input stops bubbling past it. The menu behind the modal won't receive any keypresses:

```tsx title="Modal with FocusTrap"
import { FocusGroup, FocusTrap, useFocus, useKeybindings } from 'giggles';
import { Box, Text } from 'ink';
import { useState } from 'react';

function App() {
  const [showModal, setShowModal] = useState(false);

  return (
    <Box flexDirection="column">
      <FocusGroup direction="vertical" keybindings={{ m: () => setShowModal(true) }}>
        <MenuItem label="New File" />
        <MenuItem label="Open File" />
        <MenuItem label="Save" />
      </FocusGroup>
      {showModal && (
        <FocusTrap>
          <Modal onClose={() => setShowModal(false)} />
        </FocusTrap>
      )}
    </Box>
  );
}
```

<Terminal>
  <FocusTrapExample />
</Terminal>
