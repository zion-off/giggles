---
title: Input
description: API reference for the input system
---

import { Callout } from 'fumadocs-ui/components/callout';
import { TypeTable } from 'fumadocs-ui/components/type-table';
import { Terminal } from '@/components/terminal';
import FileListExample from '@/components/examples/input/file-list';
import CaptureModeExample from '@/components/examples/input/capture-mode';
import FocusTrapExample from '@/components/examples/input/focus-trap';

The input system routes keyboard events to the focused component and its ancestors.

Register handlers with `useKeybindings` — when a key is pressed, the focused component's bindings are checked first, then its parent's, and so on. The first matching binding wins; unmatched keys keep moving up. Components outside the focused path never receive input.

For modal-like scenarios, `FocusTrap` locks input inside a subtree — nothing outside it is reachable until the trap unmounts.

```tsx title="Basic Usage"
import { useKeybindings, useFocusNode } from 'giggles';
import { useState } from 'react';
import { Box, Text } from 'ink';

function FileList() {
  const focus = useFocusNode();
  const [selected, setSelected] = useState(0);
  const files = ['file1.ts', 'file2.ts', 'file3.ts'];

  useKeybindings(focus, {
    j: () => setSelected((i) => Math.min(files.length - 1, i + 1)),
    k: () => setSelected((i) => Math.max(0, i - 1)),
  });

  return (
    <Box flexDirection="column">
      {files.map((file, i) => (
        <Text key={file} color={i === selected ? 'green' : 'white'}>
          {i === selected ? '> ' : '  '}
          {file}
        </Text>
      ))}
    </Box>
  );
}
```

## API Reference

### useKeybindings()

Registers keybindings that only fire when the component is focused.

You can call `useKeybindings` multiple times in the same component — bindings from all calls are merged together. Later calls override earlier ones for duplicate keys.

**Capture mode:** When `capture: true` is active, named bindings are checked first. If a key has no named binding, it falls through to `onKeypress`. Keys in `passthrough` skip `onKeypress` and bubble to parent scopes instead. This makes text input intuitive:

```tsx
// These navigation bindings work normally
useKeybindings(focus, {
  j: moveDown,
  k: moveUp,
  enter: select,
  escape: clearInput
});

// When searchMode is true, capture intercepts j/k for text input
// but escape/enter pass through to named bindings above
useKeybindings(
  focus,
  { enter: confirmSearch }, // Override enter when searching
  { capture: searchMode, passthrough: ['escape', 'enter'] }
);
```

```ts title="Type Signature"
function useKeybindings(
  focus: { id: string },
  bindings: Keybindings,
  options?: KeybindingOptions
): void
```

**Parameters:**

<TypeTable
  type={{
    focus: {
      description: 'Focus handle from useFocusNode() or useFocusScope()',
      type: '{ id: string }',
      required: true,
    },
    bindings: {
      description: 'Map of key names to handler functions',
      type: 'Keybindings',
      required: true,
    },
    options: {
      description: 'Optional configuration for capture mode and layers',
      type: 'KeybindingOptions',
    },
  }}
/>

#### KeyHandler

Handler function for a key binding.

```ts title="Type Signature"
type KeyHandler = (input: string, key: Key) => void
```

<TypeTable
  type={{
    input: {
      description: 'The character string for the key pressed',
      type: 'string',
      required: true,
    },
    key: {
      description: 'Ink Key object with boolean properties (downArrow, return, escape, etc.)',
      type: 'Key',
      required: true,
    },
  }}
/>

#### Keybindings

Each value can be a plain handler function or a named binding object. Named bindings are registered in the command registry and become discoverable via `useKeybindingRegistry`.

<TypeTable
  type={{
    '[key: string]': {
      description: 'Key name mapped to a handler function or named binding object. See Key Names below for valid key strings.',
      type: 'KeyHandler | { action: KeyHandler; name: string; when?: "focused" | "mounted" }',
    },
  }}
/>

The `when` field controls when the binding is considered available:
- `"focused"` (default) — active only when the registering component is the focused leaf
- `"mounted"` — active whenever the component is mounted, regardless of focus. Fires even if the component is not in the current focus path.

#### Key Names

Use these strings as keys in the bindings object:

| Key string | Triggers on |
|---|---|
| `up`, `down`, `left`, `right` | Arrow keys |
| `enter` | Return / Enter |
| `escape` | Escape |
| `tab` | Tab |
| `shift+tab` | Shift + Tab |
| `backspace` | Backspace or Delete (⌫) |
| `delete` | Forward delete (⌦) |
| `pageup`, `pagedown` | Page Up / Page Down |
| `home`, `end` | Home / End |
| `ctrl+c`, `ctrl+q`, … | Ctrl + any letter |
| `a`, `j`, `?`, … | Any printable character |

#### KeybindingOptions

Capture mode is designed for text input — it routes unhandled keypresses to `onKeypress` so printable characters reach your handler. Named bindings always take priority and fire before capture mode is considered.

**Dispatch order:**

1. **Named bindings** — always checked first, capture mode or not
2. **`onKeypress`** — called if no named binding matched and the key is not in `passthrough`
3. **Parent scope** — key bubbles up if it's in `passthrough` and has no named binding

<Callout type="warn">
Named bindings registered with capture mode options (i.e., when `onKeypress` is provided) are only active when `capture: true`. When `capture: false`, those bindings are inactive, allowing other registrations to handle those keys. This lets you register the same key (like `enter`) with different behaviors for navigation mode vs. input mode.
</Callout>

<TypeTable
  type={{
    capture: {
      description: 'When enabled, unmatched keystrokes go to onKeypress instead of being handled by parent components',
      type: 'boolean',
      default: 'false',
    },
    onKeypress: {
      description: 'Handler for keystrokes in capture mode that don\'t match named bindings',
      type: '(input: string, key: Key) => void',
    },
    passthrough: {
      description: 'Key names that skip onKeypress and bubble to parent components instead. Use for keys like tab and escape that should always reach parent scopes.',
      type: 'string[]',
    },
    layer: {
      description: 'Optional layer identifier for organizing keybindings (metadata only)',
      type: 'string',
    },
  }}
/>

### useKeybindingRegistry()

Reads all named keybindings registered across the app. Useful for building command palettes, help screens, and key hints bars.

```tsx title="Help Screen"
import { useKeybindingRegistry } from 'giggles';
import { Box, Text } from 'ink';

function HelpScreen() {
  const registry = useKeybindingRegistry();

  return (
    <Box flexDirection="column">
      {registry.available.map((cmd) => (
        <Box key={`${cmd.nodeId}-${cmd.key}`} gap={2}>
          <Text color="cyan">{cmd.key}</Text>
          <Text>{cmd.name}</Text>
        </Box>
      ))}
    </Box>
  );
}
```

<TypeTable
  type={{
    all: {
      description: 'All named bindings registered across the entire app',
      type: 'RegisteredKeybinding[]',
      required: true,
    },
    available: {
      description: 'Named bindings currently reachable — focused/ancestor bindings from the active focus path, plus all mounted bindings',
      type: 'RegisteredKeybinding[]',
      required: true,
    },
    local: {
      description: 'Named bindings registered by the component that passed its focus handle. Empty if no focus handle provided.',
      type: 'RegisteredKeybinding[]',
      required: true,
    },
  }}
/>

#### RegisteredKeybinding

<TypeTable
  type={{
    nodeId: {
      description: 'Focus node ID of the registering component',
      type: 'string',
      required: true,
    },
    key: {
      description: 'The key name the binding is registered under',
      type: 'string',
      required: true,
    },
    handler: {
      description: 'The handler function',
      type: 'KeyHandler',
      required: true,
    },
    name: {
      description: 'Human-readable label (only present on named bindings)',
      type: 'string | undefined',
    },
    when: {
      description: 'Availability scope of the binding',
      type: '"focused" | "mounted" | undefined',
    },
  }}
/>

### FocusTrap

Isolates input within a boundary. When mounted, it captures focus into its subtree and prevents input from reaching components outside. When unmounted, it restores focus to the previously focused component.

```tsx title="FocusTrap Example"
function App() {
  const [showModal, setShowModal] = useState(false);

  return (
    <>
      <MainContent />
      {showModal && (
        <FocusTrap>
          <Modal onClose={() => setShowModal(false)} />
        </FocusTrap>
      )}
    </>
  );
}
```

<TypeTable
  type={{
    children: {
      description: 'Components that should trap input',
      type: 'React.ReactNode',
      required: true,
    },
  }}
/>

## Examples

### File manager with search

This example demonstrates multiple keybindings, capture mode for search input, and dynamic filtering:

```tsx title="File Manager"
import { useFocusNode, useKeybindings } from 'giggles';
import { useState } from 'react';
import { Box, Text } from 'ink';

function FileManager() {
  const focus = useFocusNode();
  const [selected, setSelected] = useState(0);
  const [files, setFiles] = useState([
    { name: 'App.tsx', size: '2.4 KB' },
    { name: 'utils.ts', size: '1.8 KB' },
    { name: 'styles.css', size: '856 B' },
    // ... more files
  ]);
  const [searchMode, setSearchMode] = useState(false);
  const [searchQuery, setSearchQuery] = useState('');

  const filteredFiles = searchMode
    ? files.filter(f => f.name.toLowerCase().includes(searchQuery.toLowerCase()))
    : files;

  const deleteFile = () => {
    const fileToDelete = filteredFiles[selected];
    setFiles(files.filter(f => f.name !== fileToDelete.name));
  };

  // Navigation and actions
  useKeybindings(focus, {
    j: () => setSelected((i) => Math.min(filteredFiles.length - 1, i + 1)),
    k: () => setSelected((i) => Math.max(0, i - 1)),
    enter: () => console.log('Open', filteredFiles[selected].name),
    d: deleteFile,
    '/': () => setSearchMode(true),
    escape: () => setSearchMode(false)
  });

  // Search mode - capture intercepts j/k for text input
  useKeybindings(
    focus,
    { enter: () => setSearchMode(false) }, // Override enter when searching
    {
      capture: searchMode,
      passthrough: ['escape', 'enter'],
      onKeypress: (input, key) => {
        if (key.backspace) {
          setSearchQuery(q => q.slice(0, -1));
        } else if (input) {
          setSearchQuery(q => q + input);
        }
      },
    }
  );

  return (
    <Box flexDirection="column">
      {searchMode && (
        <Text>Search: {searchQuery}█</Text>
      )}
      {filteredFiles.map((file, i) => (
        <Text key={file.name} color={i === selected ? 'green' : 'white'}>
          {i === selected ? '▸ ' : '  '}{file.name} {file.size}
        </Text>
      ))}
    </Box>
  );
}
```

<Terminal>
  <FileListExample />
</Terminal>

### Text input with capture mode

Capture mode is essential for building text inputs. This form demonstrates switching between navigation and editing modes:

```tsx title="Contact Form"
import { useFocusNode, useKeybindings } from 'giggles';
import { useState } from 'react';
import { Box, Text } from 'ink';

function ContactForm() {
  const focus = useFocusNode();
  const [formData, setFormData] = useState({ name: '', email: '', message: '' });
  const [activeField, setActiveField] = useState('name');
  const [editing, setEditing] = useState(false);

  const fields = ['name', 'email', 'message'];
  const currentIndex = fields.indexOf(activeField);

  // Navigation keybindings
  useKeybindings(focus, {
    j: () => setActiveField(fields[Math.min(currentIndex + 1, 2)]),
    k: () => setActiveField(fields[Math.max(currentIndex - 1, 0)]),
    enter: () => setEditing(true),
    escape: () => setEditing(false)
  });

  // Edit mode - capture intercepts j/k for text input
  useKeybindings(
    focus,
    {
      enter: () => {
        setEditing(false);
        if (currentIndex < 2) setActiveField(fields[currentIndex + 1]);
      },
    },
    {
      capture: editing,
      passthrough: ['escape', 'enter'],
      onKeypress: (input, key) => {
        if (key.backspace) {
          setFormData(prev => ({
            ...prev,
            [activeField]: prev[activeField].slice(0, -1)
          }));
        } else if (input) {
          setFormData(prev => ({
            ...prev,
            [activeField]: prev[activeField] + input
          }));
        }
      },
    }
  );

  return (
    <Box flexDirection="column">
      {fields.map(field => (
        <Box key={field} flexDirection="column">
          <Text color={field === activeField ? 'yellow' : 'grey'}>
            {field}:
          </Text>
          <Text>
            {field === activeField ? '▸ ' : '  '}
            {formData[field]}
            {editing && field === activeField && '█'}
          </Text>
        </Box>
      ))}
    </Box>
  );
}
```

<Terminal>
  <CaptureModeExample />
</Terminal>

### Focus trap for modals

When a `FocusTrap` is active, input stops bubbling past it. The menu behind the modal won't receive any keypresses:

```tsx title="Modal with FocusTrap"
import { FocusScope, FocusTrap, useFocusNode, useFocusScope, useKeybindings } from 'giggles';
import { Box, Text } from 'ink';
import { useState } from 'react';

function MenuItem({ label, onSelect }) {
  const focus = useFocusNode();

  useKeybindings(focus, {
    enter: () => onSelect?.()
  });

  return (
    <Text color={focus.hasFocus ? 'green' : 'white'}>
      {focus.hasFocus ? '▸ ' : '  '}{label}
    </Text>
  );
}

function ConfirmDialog({ message, onConfirm, onCancel }) {
  const scope = useFocusScope({
    keybindings: ({ next, prev }) => ({
      left: prev,
      right: next,
      escape: onCancel
    })
  });

  return (
    <Box flexDirection="column" borderStyle="double">
      <Text bold color="yellow">Confirm Action</Text>
      <Text>{message}</Text>
      <FocusScope handle={scope}>
        <MenuItem label="Confirm" onSelect={onConfirm} />
        <MenuItem label="Cancel" onSelect={onCancel} />
      </FocusScope>
    </Box>
  );
}

function App() {
  const [showModal, setShowModal] = useState(false);
  const menuScope = useFocusScope({
    keybindings: ({ next, prev }) => ({ j: next, k: prev })
  });

  return (
    <Box flexDirection="column">
      <FocusScope handle={menuScope}>
        <MenuItem label="New File" onSelect={() => setShowModal(true)} />
        <MenuItem label="Delete" onSelect={() => setShowModal(true)} />
      </FocusScope>

      {showModal && (
        <FocusTrap>
          <ConfirmDialog
            message="Are you sure?"
            onConfirm={() => setShowModal(false)}
            onCancel={() => setShowModal(false)}
          />
        </FocusTrap>
      )}
    </Box>
  );
}
```

<Terminal>
  <FocusTrapExample />
</Terminal>
