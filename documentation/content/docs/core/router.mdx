---
title: Router
description: API reference for the screen router
---

import { TypeTable } from 'fumadocs-ui/components/type-table';
import { Callout } from 'fumadocs-ui/components/callout';
import BasicRouterExample from '@/components/examples/router/basic-router';

Stack-based screen navigation. Screens stay mounted when pushed to preserve state.

When you `push` a screen, it's added to the top of the stack. When you `pop`, the top screen is removed and the previous one becomes visible again. Hidden screens remain mounted so they don't lose state.

The Router integrates with the focus system automatically — when a screen becomes the top of the stack, its first focusable child receives focus. When navigating back to a previous screen, focus is restored to whichever element was focused before the screen was covered. This can be disabled with `restoreFocus={false}`, which always focuses the first child instead.

```tsx title="Basic Usage"
import { GigglesProvider, Router, Screen, useNavigation, useFocus, useKeybindings } from 'giggles';
import { Text } from 'ink';

function App() {
  return (
    <GigglesProvider>
      <Router initialScreen="home">
        <Screen name="home" component={Home} />
        <Screen name="settings" component={Settings} />
      </Router>
    </GigglesProvider>
  );
}

function Home() {
  const { push } = useNavigation();
  const focus = useFocus();

  useKeybindings(focus, {
    s: () => push('settings'),
  });

  return <Text>Home <Text dimColor>Press s for settings</Text></Text>;
}

function Settings() {
  const { pop, canGoBack } = useNavigation();
  const focus = useFocus();

  useKeybindings(focus, {
    q: () => pop(),
  });

  return <Text>Settings {canGoBack && <Text dimColor>Press q to go back</Text>}</Text>;
}
```

<Terminal>
  <BasicRouterExample />
</Terminal>

## API Reference

### Router

Manages a stack of screens. Only the top screen is visible; others remain mounted but hidden.

<TypeTable
  type={{
    initialScreen: {
      description: 'Name of the screen to display first. Must match a Screen child.',
      type: 'string',
      required: true,
    },
    initialParams: {
      description: 'Params to pass to the initial screen',
      type: 'Record<string, unknown>',
    },
    restoreFocus: {
      description: 'Restore the previously focused element when returning to a screen. When false, always focuses the first child.',
      type: 'boolean',
      default: 'true',
    },
    children: {
      description: 'Screen components defining available routes',
      type: 'React.ReactNode',
      required: true,
    },
  }}
/>

<Callout type="warn">
  Throws a `GigglesError` if `initialScreen` does not match any registered Screen name.
</Callout>

### Screen

Declarative route definition. Renders nothing — used by Router to register screens.

<TypeTable
  type={{
    name: {
      description: 'Unique name for this screen',
      type: 'string',
      required: true,
    },
    component: {
      description: 'Component to render when this screen is active',
      type: 'React.ComponentType',
      required: true,
    },
  }}
/>

### useNavigation()

Returns navigation methods and current route state. Must be used within a Router.

```ts title="Type Signature"
function useNavigation(): NavigationContextValue
```

**Returns:** `NavigationContextValue`

<TypeTable
  type={{
    currentRoute: {
      description: 'The current screen route (name, params, id)',
      type: 'ScreenRoute',
      required: true,
    },
    active: {
      description: 'Whether this screen is the top of the stack',
      type: 'boolean',
      required: true,
    },
    canGoBack: {
      description: 'Whether the stack has more than one screen',
      type: 'boolean',
      required: true,
    },
    push: {
      description: 'Push a new screen onto the stack',
      type: '(name: string, params?: Record<string, unknown>) => void',
      required: true,
    },
    pop: {
      description: 'Remove the top screen from the stack. No-op if only one screen remains.',
      type: '() => void',
      required: true,
    },
    replace: {
      description: 'Replace the top screen with a new one',
      type: '(name: string, params?: Record<string, unknown>) => void',
      required: true,
    },
    reset: {
      description: 'Clear the stack and set a single screen',
      type: '(name: string, params?: Record<string, unknown>) => void',
      required: true,
    },
  }}
/>

#### ScreenRoute

<TypeTable
  type={{
    id: {
      description: 'Unique identifier for this stack entry',
      type: 'number',
      required: true,
    },
    name: {
      description: 'The screen name as registered with Screen',
      type: 'string',
      required: true,
    },
    params: {
      description: 'Params passed when the screen was pushed',
      type: 'Record<string, unknown>',
    },
  }}
/>

<Callout type="warn">
  `push`, `replace`, and `reset` throw a `GigglesError` if the screen name is not registered.
</Callout>

## Nested Routers

Each Router manages its own independent stack. You can nest routers for tabbed layouts or sub-navigation:

```tsx title="Nested Routers"
function App() {
  return (
    <GigglesProvider>
      <Router initialScreen="tabs">
        <Screen name="tabs" component={Tabs} />
        <Screen name="detail" component={Detail} />
      </Router>
    </GigglesProvider>
  );
}

function Tabs() {
  return (
    <Router initialScreen="tab1">
      <Screen name="tab1" component={Tab1} />
      <Screen name="tab2" component={Tab2} />
    </Router>
  );
}
```
