---
title: API Reference
description: API reference for the focus system
---

import { TypeTable } from 'fumadocs-ui/components/type-table';
import { Callout } from 'fumadocs-ui/components/callout';

### useFocusScope()

Creates a scope node in the focus tree and returns a reactive handle. Wrap children with `<FocusScope handle={scope}>` so nested hooks know their parent.

```ts title="Type Signature"
function useFocusScope(options?: FocusScopeOptions): FocusScopeHandle
```

#### FocusScopeOptions

<TypeTable
  type={{
    parent: {
      description: 'Explicit parent scope. Use when creating a scope in the same component as its parent, bypassing context. Defaults to the nearest <FocusScope> ancestor.',
      type: 'FocusScopeHandle',
    },
    focusKey: {
      description: 'Key used to address this scope from its parent via focusChild/focusChildShallow. Scoped to the immediate parent — no global namespace.',
      type: 'string',
    },
    keybindings: {
      description: 'Keybindings active while this scope or any descendant has focus. Pass a function to receive navigation helpers. Handlers re-register every render so closures are never stale. To register additional keys on the scope or handle text input, use useKeybindings() alongside this option.',
      type: 'Keybindings | ((helpers: FocusScopeHelpers) => Keybindings)',
    },
  }}
/>

#### FocusScopeHandle

<TypeTable
  type={{
    id: {
      description: 'Unique identifier for this scope node',
      type: 'string',
      required: true,
    },
    hasFocus: {
      description: 'Whether this scope or any descendant currently has focus',
      type: 'boolean',
      required: true,
    },
    isPassive: {
      description: 'Whether this scope is in passive mode — focus has been yielded to the parent via escape()',
      type: 'boolean',
      required: true,
    },
    next: {
      description: 'Focus the next sibling child, descending to the first leaf automatically.',
      type: '() => void',
      required: true,
    },
    prev: {
      description: 'Focus the previous sibling child, descending to the first leaf automatically.',
      type: '() => void',
      required: true,
    },
    nextShallow: {
      description: 'Focus the next sibling child without descending into its children.',
      type: '() => void',
      required: true,
    },
    prevShallow: {
      description: 'Focus the previous sibling child without descending into its children.',
      type: '() => void',
      required: true,
    },
    escape: {
      description: "Yield focus to this scope's own node, enabling passive mode. Parent keybindings become active.",
      type: '() => void',
      required: true,
    },
    drillIn: {
      description: 'Focus the first child of this scope, clearing passive mode. If the scope has no children yet, the focus is queued — the first child to register claims it automatically.',
      type: '() => void',
      required: true,
    },
    focusChild: {
      description: 'Focus the direct child of this scope with the given focusKey, drilling into its first leaf. If the child is a scope with no children yet, the focus is queued. No-op if the key is not found.',
      type: '(key: string) => void',
      required: true,
    },
    focusChildShallow: {
      description: 'Focus the direct child of this scope with the given focusKey, landing on its scope node without drilling in. No-op if the key is not found.',
      type: '(key: string) => void',
      required: true,
    },
  }}
/>

`hasFocus` is how a container knows it's in the active focus path — use it for visual feedback, conditional rendering, or any logic that depends on whether the user's attention is inside this scope. `isPassive` reflects the current navigation mode: when true, this scope has yielded and the parent's bindings are active — surface it so the user knows which level they're navigating.

The navigation methods (`next`, `prev`, `drillIn`, etc.) are stable references, safe to call from event handlers. Call them imperatively, not during render.

#### FocusScopeHelpers

The subset of `FocusScopeHandle` passed as the argument to the `keybindings` factory function.

<TypeTable
  type={{
    next: { description: 'Focus the next sibling child, descending to the first leaf automatically.', type: '() => void', required: true },
    prev: { description: 'Focus the previous sibling child, descending to the first leaf automatically.', type: '() => void', required: true },
    nextShallow: { description: 'Focus the next sibling child without descending into its children.', type: '() => void', required: true },
    prevShallow: { description: 'Focus the previous sibling child without descending into its children.', type: '() => void', required: true },
    escape: { description: "Yield focus to this scope's own node, enabling passive mode. Parent keybindings become active.", type: '() => void', required: true },
    drillIn: { description: 'Focus the first child of this scope, clearing passive mode. Queues focus if the scope has no children yet.', type: '() => void', required: true },
    focusChild: { description: 'Focus the direct child registered with the given focusKey, drilling into its first leaf.', type: '(key: string) => void', required: true },
    focusChildShallow: { description: 'Focus the direct child registered with the given focusKey, landing on its scope node without drilling.', type: '(key: string) => void', required: true },
  }}
/>

### FocusScope

Sets the parent scope for all children rendered inside it. Children that call `useFocusNode()` or `useFocusScope()` without an explicit `parent` option register under this scope.

<Callout type="warn">
  Every `useFocusScope()` call must have exactly one corresponding `<FocusScope>` rendered. Omitting it throws a `GigglesError` — without it, children silently register under the wrong parent scope and navigation breaks.
</Callout>

```tsx title="Type Signature"
function FocusScope({ handle, children }: {
  handle: FocusScopeHandle;
  children: React.ReactNode;
}): JSX.Element
```

<TypeTable
  type={{
    handle: {
      description: 'The scope handle returned by useFocusScope()',
      type: 'FocusScopeHandle',
      required: true,
    },
    children: {
      description: 'Child components that will register under this scope',
      type: 'React.ReactNode',
      required: true,
    },
  }}
/>

### useFocusNode()

Registers a component as a leaf node in the focus tree. Use this when the component itself is the focusable target — a list item, a form field, a button. If the component contains other focusable children, use `useFocusScope` instead.

```ts title="Type Signature"
function useFocusNode(options?: FocusNodeOptions): FocusNodeHandle
```

#### FocusNodeOptions

<TypeTable
  type={{
    parent: {
      description: 'Explicit parent scope. Use when creating a node in the same component as its parent scope, bypassing context. Defaults to the nearest <FocusScope> ancestor.',
      type: 'FocusScopeHandle',
    },
    focusKey: {
      description: 'Key used to address this node from its parent scope via focusChild/focusChildShallow. Scoped to the immediate parent — no global namespace.',
      type: 'string',
    },
  }}
/>

#### FocusNodeHandle

<TypeTable
  type={{
    id: {
      description: 'Unique identifier for this focus node',
      type: 'string',
      required: true,
    },
    hasFocus: {
      description: 'Whether this node currently has focus',
      type: 'boolean',
      required: true,
    },
  }}
/>

The `FocusNodeHandle` type can be imported for typing component props:

```tsx title="Typing Props"
import type { FocusNodeHandle } from 'giggles';

function MyComponent({ focus }: { focus: FocusNodeHandle }) {
  return <Text color={focus.hasFocus ? 'green' : 'white'}>Item</Text>;
}
```
