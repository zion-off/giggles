---
title: Focus
description: API reference for the focus system
---

import { TypeTable } from 'fumadocs-ui/components/type-table';
import { Callout } from 'fumadocs-ui/components/callout';
import { Terminal } from '@/components/terminal';
import NavigableMenuExample from '@/components/examples/focus/navigable-menu';
import ControlledFocusExample from '@/components/examples/focus/controlled-focus';
import FileTreeExample from '@/components/examples/focus/file-tree';

The focus system provides hooks and components for managing keyboard navigation.

`useFocusScope` is the scoping primitive — it creates a navigable region and returns a handle with reactive focus state. Wrap children with `<FocusScope>` to set the parent context, so any child that calls `useFocusNode()` automatically registers under that scope.

Navigation between children is explicit: pass a `keybindings` function to `useFocusScope` that receives `next`, `prev`, and `escape` helpers and returns a key map. This makes nested layouts composable — each scope only handles the keys you assign it.

```tsx title="Navigable Menu"
import { FocusScope, useFocusNode, useFocusScope } from 'giggles';

function Menu() {
  const scope = useFocusScope({
    keybindings: ({ next, prev }) => ({ j: next, k: prev, down: next, up: prev })
  });

  return (
    <FocusScope handle={scope}>
      <MenuItem label="New File" />
      <MenuItem label="Open File" />
      <MenuItem label="Save" />
    </FocusScope>
  );
}

function MenuItem({ label }: { label: string }) {
  const focus = useFocusNode();
  return (
    <Text color={focus.hasFocus ? 'green' : 'white'}>
      {focus.hasFocus ? '> ' : '  '}
      {label}
    </Text>
  );
}
```

<Terminal>
  <NavigableMenuExample />
</Terminal>

## API Reference

### useFocusScope()

Creates a scope node in the focus tree and returns a reactive handle. The scope acts as a grouping container — children that call `useFocusNode()` or `useFocusScope()` without an explicit `parent` register under the nearest `<FocusScope>` ancestor.

```ts title="Type Signature"
function useFocusScope(options?: FocusScopeOptions): FocusScopeHandle
```

**Parameters:**

<TypeTable
  type={{
    options: {
      description: 'Optional configuration for the scope',
      type: 'FocusScopeOptions',
    },
  }}
/>

**Returns:** `FocusScopeHandle`

#### FocusScopeOptions

<TypeTable
  type={{
    parent: {
      description: 'Explicit parent scope. Defaults to the nearest <FocusScope> ancestor via context.',
      type: 'FocusScopeHandle',
    },
    keybindings: {
      description: 'Keybindings active while this scope or any descendant has focus. Pass a function to receive navigation helpers.',
      type: 'Keybindings | ((helpers: FocusScopeHelpers) => Keybindings)',
    },
  }}
/>

#### FocusScopeHandle

<TypeTable
  type={{
    id: {
      description: 'Unique identifier for this scope node',
      type: 'string',
      required: true,
    },
    hasFocus: {
      description: 'Whether this scope or any descendant currently has focus',
      type: 'boolean',
      required: true,
    },
    isPassive: {
      description: 'Whether this scope is in passive mode — focus has been yielded to the parent via escape()',
      type: 'boolean',
      required: true,
    },
  }}
/>

Use `hasFocus` for visual indicators like borders and highlights. Use `isPassive` to show that a scope has been escaped from — for example, dimming a border when j/k will navigate at the parent level instead.

#### FocusScopeHelpers

<TypeTable
  type={{
    next: {
      description: 'Focus the next sibling within this scope, descending to the first leaf automatically.',
      type: '() => void',
      required: true,
    },
    prev: {
      description: 'Focus the previous sibling within this scope, descending to the first leaf automatically.',
      type: '() => void',
      required: true,
    },
    nextShallow: {
      description: 'Focus the next sibling without descending into child scopes.',
      type: '() => void',
      required: true,
    },
    prevShallow: {
      description: 'Focus the previous sibling without descending into child scopes.',
      type: '() => void',
      required: true,
    },
    escape: {
      description: 'Yield focus to this scope\'s own node, enabling passive mode. Parent keybindings become active.',
      type: '() => void',
      required: true,
    },
    drillIn: {
      description: 'Focus the first child of this scope, clearing passive mode.',
      type: '() => void',
      required: true,
    },
  }}
/>

### FocusScope

Sets the parent scope for all children rendered inside it. Children that call `useFocusNode()` or `useFocusScope()` without an explicit `parent` option will register under this scope.

```tsx title="Type Signature"
function FocusScope({ handle, children }: {
  handle: FocusScopeHandle;
  children: React.ReactNode;
}): JSX.Element
```

<TypeTable
  type={{
    handle: {
      description: 'The scope handle returned by useFocusScope()',
      type: 'FocusScopeHandle',
      required: true,
    },
    children: {
      description: 'Child components that will register under this scope',
      type: 'React.ReactNode',
      required: true,
    },
  }}
/>

### useFocusNode()

Registers a component as a leaf node in the focus tree. Use this for components that are themselves focusable targets: list items, form fields, buttons.

```ts title="Type Signature"
function useFocusNode(options?: FocusNodeOptions): FocusNodeHandle
```

**Parameters:**

<TypeTable
  type={{
    options: {
      description: 'Optional configuration for the node',
      type: 'FocusNodeOptions',
    },
  }}
/>

**Returns:** `FocusNodeHandle`

#### FocusNodeOptions

<TypeTable
  type={{
    parent: {
      description: 'Explicit parent scope. Defaults to the nearest <FocusScope> ancestor via context.',
      type: 'FocusScopeHandle',
    },
  }}
/>

#### FocusNodeHandle

<TypeTable
  type={{
    id: {
      description: 'Unique identifier for this focus node',
      type: 'string',
      required: true,
    },
    hasFocus: {
      description: 'Whether this node currently has focus',
      type: 'boolean',
      required: true,
    },
  }}
/>

The `FocusNodeHandle` type can be imported for typing component props:

```tsx title="Typing Props"
import type { FocusNodeHandle } from 'giggles';

function MyComponent({ focus }: { focus: FocusNodeHandle }) {
  return <Text color={focus.hasFocus ? 'green' : 'white'}>Item</Text>;
}
```

## Examples

### Nested navigation

If inner and outer scopes use different keys, normal key bubbling handles the separation automatically — no extra machinery needed. Passive mode only becomes necessary when the same keys need to mean different things at different nesting levels.

In this example, `j`/`k` navigate items inside each panel and also switch between panels at the root. Because the inner scope consumes `j`/`k`, they never reach the root while a panel is active. Calling `escape()` puts the panel into passive mode — it is skipped during dispatch, so the root's `j`/`k` fire instead. Passive mode clears automatically when focus moves to a different scope.

```tsx title="Two Panels"
function Panel({ title, items }: { title: string; items: string[] }) {
  const scope = useFocusScope({
    keybindings: ({ escape }) => ({ e: escape })  // yield — parent's j/k take over
  });

  return (
    <FocusScope handle={scope}>
      <Box
        borderStyle="round"
        borderColor={scope.isPassive ? 'yellow' : scope.hasFocus ? 'green' : 'grey'}
      >
        <Text>{title}</Text>
        <Select options={items.map(i => ({ label: i, value: i }))} />
      </Box>
    </FocusScope>
  );
}

function App() {
  const root = useFocusScope({
    keybindings: ({ next, prev }) => ({ j: next, k: prev })
  });

  return (
    <FocusScope handle={root}>
      <Panel title="Navigation" items={['Home', 'About', 'Contact']} />
      <Panel title="Tools" items={['Grep', 'Find', 'Awk']} />
    </FocusScope>
  );
}
```

<Terminal>
  <ControlledFocusExample />
</Terminal>

### File tree

A collapsible file tree with two levels of navigation. The root scope uses `nextShallow`/`prevShallow` to move between top-level entries without drilling into their children — so a closed directory lands focus on the directory node, where `l`/`enter` open it. When open, the directory scope's `j: next` descends into the file list. Inside the file list, `j`/`k` navigate between files and `h` collapses back.

The directory header's color reflects `scope.hasFocus`, which is true whenever any descendant — including files deep inside — has focus. This eliminates the need for a separate hook to read parent focus state.

```tsx title="File Tree"
import { FocusScope, useFocusScope, useTheme } from 'giggles';
import { Select } from 'giggles/ui';

function DirItem({ name, files }: { name: string; files: string[] }) {
  const [open, setOpen] = useState(false);
  const { indicator, indicatorOpen } = useTheme();

  const scope = useFocusScope({
    keybindings: ({ next }) =>
      open
        ? { j: next, h: () => setOpen(false) }
        : { l: () => setOpen(true), enter: () => setOpen(true) }
  });

  return (
    <FocusScope handle={scope}>
      <Box flexDirection="column">
        <Text color={scope.hasFocus ? 'green' : 'white'}>
          {open ? indicatorOpen : indicator} {name}/
        </Text>
        {open && (
          <Select options={files.map(f => ({ label: f, value: f }))} />
        )}
      </Box>
    </FocusScope>
  );
}

function FileTree() {
  const root = useFocusScope({
    keybindings: ({ nextShallow, prevShallow }) => ({
      j: nextShallow, k: prevShallow
    })
  });

  return (
    <FocusScope handle={root}>
      <DirItem name="src" files={['index.ts', 'utils.ts', 'types.ts']} />
      <DirItem name="tests" files={['unit.test.ts', 'e2e.test.ts']} />
    </FocusScope>
  );
}
```

<Terminal>
  <FileTreeExample />
</Terminal>
