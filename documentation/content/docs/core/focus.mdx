---
title: Focus
description: Hooks and components for managing keyboard navigation
---

import { TypeTable } from 'fumadocs-ui/components/type-table';
import { Callout } from 'fumadocs-ui/components/callout';
import { Terminal } from '@/components/terminal';
import NavigableMenuExample from '@/components/examples/focus/navigable-menu';
import ControlledFocusExample from '@/components/examples/focus/controlled-focus';
import FileTreeExample from '@/components/examples/focus/file-tree';

## Nodes and scopes

The focus tree has two kinds of participants.

A **node** (`useFocusNode`) is a focusable target — a list item, a text field, a button. It can receive focus and respond to keys, but has no children in the focus tree.

A **scope** (`useFocusScope`) is a navigable container. It groups focusable children and controls how focus moves between them. Scopes can contain other scopes — nesting is how complex layouts are built.

**Decision rule:** if your component *contains* focusable children, use `useFocusScope`. If your component *is* the focusable target, use `useFocusNode`. UI components like `Select` and `TextInput` use `useFocusNode` internally — they are leaf nodes, not containers.

## Navigation is per level

Each scope independently navigates its own direct children. The parent scope owns the movement keys; children don't move themselves.

At the boundary between a scope and a child scope, you choose how to cross:

- `next` / `prev` — move to the next or previous child and **drill in**, landing on its first leaf
- `nextShallow` / `prevShallow` — move to the next or previous child and **stop at the scope node**, without entering it

The shallow variants are essential when children may be collapsed or have no registered descendants yet — `next` would queue indefinitely on an empty scope, while `nextShallow` lands on the scope node where the user can choose to open it.

## `hasFocus` propagates up

Focus always lives at a single leaf node. But `hasFocus` on a scope is true whenever *any descendant* has focus — the value propagates up the tree. A container can highlight its border while focus is several levels deep inside it, with no extra state required.

```tsx
<Box borderColor={scope.hasFocus ? 'green' : 'grey'}>
```

## Keys bubble up

Keypresses walk from the focused node up to the root. At each node, if a binding matches it fires and the walk stops. If nothing matches, the key continues to the parent scope.

This means outer scopes receive any keys that inner scopes don't consume — no explicit forwarding needed. A `Select` consumes `j`/`k`/`enter`; any other key pressed while it has focus bubbles freely to the parent scope's bindings.

**Passive mode** is the exception: when inner and outer scopes bind the *same* key, call `escape()` on the inner scope to make it yield. The scope is skipped during dispatch until focus moves elsewhere.

---

## Quick start

```tsx title="Navigable Menu"
import { FocusScope, useFocusNode, useFocusScope } from 'giggles';

function Menu() {
  const scope = useFocusScope({
    keybindings: ({ next, prev }) => ({ j: next, k: prev, down: next, up: prev })
  });

  return (
    <FocusScope handle={scope}>
      <MenuItem label="New File" />
      <MenuItem label="Open File" />
      <MenuItem label="Save" />
    </FocusScope>
  );
}

function MenuItem({ label }: { label: string }) {
  const focus = useFocusNode();
  return (
    <Text color={focus.hasFocus ? 'green' : 'white'}>
      {focus.hasFocus ? '> ' : '  '}
      {label}
    </Text>
  );
}
```

<Terminal>
  <NavigableMenuExample />
</Terminal>

---

## API Reference

### useFocusScope()

Creates a scope node in the focus tree and returns a reactive handle. Wrap children with `<FocusScope handle={scope}>` so nested hooks know their parent.

```ts title="Type Signature"
function useFocusScope(options?: FocusScopeOptions): FocusScopeHandle
```

#### FocusScopeOptions

<TypeTable
  type={{
    parent: {
      description: 'Explicit parent scope. Use when creating a scope in the same component as its parent, bypassing context. Defaults to the nearest <FocusScope> ancestor.',
      type: 'FocusScopeHandle',
    },
    focusKey: {
      description: 'Key used to address this scope from its parent via focusChild/focusChildShallow. Scoped to the immediate parent — no global namespace.',
      type: 'string',
    },
    keybindings: {
      description: 'Keybindings active while this scope or any descendant has focus. Pass a function to receive navigation helpers. Handlers re-register every render so closures are never stale.',
      type: 'Keybindings | ((helpers: FocusScopeHelpers) => Keybindings)',
    },
  }}
/>

#### FocusScopeHandle

<TypeTable
  type={{
    id: {
      description: 'Unique identifier for this scope node',
      type: 'string',
      required: true,
    },
    hasFocus: {
      description: 'Whether this scope or any descendant currently has focus',
      type: 'boolean',
      required: true,
    },
    isPassive: {
      description: 'Whether this scope is in passive mode — focus has been yielded to the parent via escape()',
      type: 'boolean',
      required: true,
    },
    next: {
      description: 'Focus the next sibling child, descending to the first leaf automatically.',
      type: '() => void',
      required: true,
    },
    prev: {
      description: 'Focus the previous sibling child, descending to the first leaf automatically.',
      type: '() => void',
      required: true,
    },
    nextShallow: {
      description: 'Focus the next sibling child without descending into its children.',
      type: '() => void',
      required: true,
    },
    prevShallow: {
      description: 'Focus the previous sibling child without descending into its children.',
      type: '() => void',
      required: true,
    },
    escape: {
      description: "Yield focus to this scope's own node, enabling passive mode. Parent keybindings become active.",
      type: '() => void',
      required: true,
    },
    drillIn: {
      description: 'Focus the first child of this scope, clearing passive mode. If the scope has no children yet, the focus is queued — the first child to register claims it automatically.',
      type: '() => void',
      required: true,
    },
    focusChild: {
      description: 'Focus the direct child of this scope with the given focusKey, drilling into its first leaf. If the child is a scope with no children yet, the focus is queued. No-op if the key is not found.',
      type: '(key: string) => void',
      required: true,
    },
    focusChildShallow: {
      description: 'Focus the direct child of this scope with the given focusKey, landing on its scope node without drilling in. No-op if the key is not found.',
      type: '(key: string) => void',
      required: true,
    },
  }}
/>

Use `hasFocus` for visual indicators like borders and highlights. Use `isPassive` to show that a scope has been escaped from — for example, dimming a border when `j`/`k` will navigate at the parent level instead.

The navigation methods are stable references — safe to call from effects and event handlers. Call them imperatively, not during render.

#### FocusScopeHelpers

The subset of `FocusScopeHandle` passed as the argument to the `keybindings` factory function.

<TypeTable
  type={{
    next: { description: 'Focus the next sibling child, descending to the first leaf automatically.', type: '() => void', required: true },
    prev: { description: 'Focus the previous sibling child, descending to the first leaf automatically.', type: '() => void', required: true },
    nextShallow: { description: 'Focus the next sibling child without descending into its children.', type: '() => void', required: true },
    prevShallow: { description: 'Focus the previous sibling child without descending into its children.', type: '() => void', required: true },
    escape: { description: "Yield focus to this scope's own node, enabling passive mode. Parent keybindings become active.", type: '() => void', required: true },
    drillIn: { description: 'Focus the first child of this scope, clearing passive mode. Queues focus if the scope has no children yet.', type: '() => void', required: true },
    focusChild: { description: 'Focus the direct child registered with the given focusKey, drilling into its first leaf.', type: '(key: string) => void', required: true },
    focusChildShallow: { description: 'Focus the direct child registered with the given focusKey, landing on its scope node without drilling.', type: '(key: string) => void', required: true },
  }}
/>

### FocusScope

Sets the parent scope for all children rendered inside it. Children that call `useFocusNode()` or `useFocusScope()` without an explicit `parent` option register under this scope.

<Callout type="warn">
  Every `useFocusScope()` call must have exactly one corresponding `<FocusScope>` rendered. Omitting it throws a `GigglesError` — without it, children silently register under the wrong parent scope and navigation breaks.
</Callout>

```tsx title="Type Signature"
function FocusScope({ handle, children }: {
  handle: FocusScopeHandle;
  children: React.ReactNode;
}): JSX.Element
```

<TypeTable
  type={{
    handle: {
      description: 'The scope handle returned by useFocusScope()',
      type: 'FocusScopeHandle',
      required: true,
    },
    children: {
      description: 'Child components that will register under this scope',
      type: 'React.ReactNode',
      required: true,
    },
  }}
/>

### useFocusNode()

Registers a component as a leaf node in the focus tree. Use this when the component itself is the focusable target — a list item, a form field, a button. If the component contains other focusable children, use `useFocusScope` instead.

```ts title="Type Signature"
function useFocusNode(options?: FocusNodeOptions): FocusNodeHandle
```

#### FocusNodeOptions

<TypeTable
  type={{
    parent: {
      description: 'Explicit parent scope. Use when creating a node in the same component as its parent scope, bypassing context. Defaults to the nearest <FocusScope> ancestor.',
      type: 'FocusScopeHandle',
    },
    focusKey: {
      description: 'Key used to address this node from its parent scope via focusChild/focusChildShallow. Scoped to the immediate parent — no global namespace.',
      type: 'string',
    },
  }}
/>

#### FocusNodeHandle

<TypeTable
  type={{
    id: {
      description: 'Unique identifier for this focus node',
      type: 'string',
      required: true,
    },
    hasFocus: {
      description: 'Whether this node currently has focus',
      type: 'boolean',
      required: true,
    },
  }}
/>

The `FocusNodeHandle` type can be imported for typing component props:

```tsx title="Typing Props"
import type { FocusNodeHandle } from 'giggles';

function MyComponent({ focus }: { focus: FocusNodeHandle }) {
  return <Text color={focus.hasFocus ? 'green' : 'white'}>Item</Text>;
}
```

---

## Examples

### Controlled focus

Use `focusKey` to give a child a stable name, then call `focusChild` from the parent to jump to it directly — without `next`/`prev` iteration. Keys are scoped to the immediate parent scope, so the same key can be reused inside sibling scopes.

```tsx title="Jump to Child by Key"
function Dashboard() {
  const root = useFocusScope({
    keybindings: ({ focusChild }) => ({
      '1': () => focusChild('editor'),
      '2': () => focusChild('terminal'),
      '3': () => focusChild('sidebar'),
    })
  });

  return (
    <FocusScope handle={root}>
      <Editor focusKey="editor" />
      <Terminal focusKey="terminal" />
      <Sidebar focusKey="sidebar" />
    </FocusScope>
  );
}
```

`focusChild` drills into the first leaf of the target scope, so pressing `1` lands you inside the editor immediately — same behaviour as `next`. Use `focusChildShallow` if you want to land on the scope node itself without entering it.

`focusChild` is also available directly on the handle for use in effects and event handlers:

```tsx title="Focus Child from an Effect"
const root = useFocusScope();

useEffect(() => {
  if (errorPanel) root.focusChild('errors');
}, [errorPanel]);
```

### Nested navigation

If inner and outer scopes use different keys, normal key bubbling handles the separation automatically — no extra machinery needed. Passive mode only becomes necessary when the same keys need to mean different things at different nesting levels.

In this example, `j`/`k` navigate items inside each panel and also switch between panels at the root. Because the inner scope consumes `j`/`k`, they never reach the root while a panel is active. Calling `escape()` puts the panel into passive mode — it is skipped during dispatch, so the root's `j`/`k` fire instead. Passive mode clears automatically when focus moves to a different scope.

```tsx title="Two Panels"
function Panel({ title, items }: { title: string; items: string[] }) {
  const scope = useFocusScope({
    keybindings: ({ escape }) => ({ e: escape })  // yield — parent's j/k take over
  });

  return (
    <FocusScope handle={scope}>
      <Box
        borderStyle="round"
        borderColor={scope.isPassive ? 'yellow' : scope.hasFocus ? 'green' : 'grey'}
      >
        <Text>{title}</Text>
        <Select options={items.map(i => ({ label: i, value: i }))} />
      </Box>
    </FocusScope>
  );
}

function App() {
  const root = useFocusScope({
    keybindings: ({ next, prev }) => ({ j: next, k: prev })
  });

  return (
    <FocusScope handle={root}>
      <Panel title="Navigation" items={['Home', 'About', 'Contact']} />
      <Panel title="Tools" items={['Grep', 'Find', 'Awk']} />
    </FocusScope>
  );
}
```

<Terminal>
  <ControlledFocusExample />
</Terminal>

### File tree

A collapsible file tree with two levels of navigation. The root scope uses `nextShallow`/`prevShallow` to move between top-level entries without drilling into their children — so a closed directory lands focus on the directory node, where `l`/`enter` open it. Opening calls `drillIn()` alongside `setOpen(true)` — because `drillIn` queues focus if the scope has no children yet, the file list claims focus automatically the moment it renders. Inside the file list, `j`/`k` navigate between files and `h` collapses back.

The directory header's color reflects `scope.hasFocus`, which is true whenever any descendant — including files deep inside — has focus. This eliminates the need for a separate hook to read parent focus state.

```tsx title="File Tree"
import { FocusScope, useFocusScope, useTheme } from 'giggles';
import { Select } from 'giggles/ui';

function DirItem({ name, files }: { name: string; files: string[] }) {
  const [open, setOpen] = useState(false);
  const { indicator, indicatorOpen } = useTheme();

  const scope = useFocusScope({
    keybindings: ({ next, drillIn }) =>
      open
        ? { j: next, h: () => setOpen(false) }
        : { l: () => { setOpen(true); drillIn(); }, enter: () => { setOpen(true); drillIn(); } }
  });

  return (
    <FocusScope handle={scope}>
      <Box flexDirection="column">
        <Text color={scope.hasFocus ? 'green' : 'white'}>
          {open ? indicatorOpen : indicator} {name}/
        </Text>
        {open && (
          <Select options={files.map(f => ({ label: f, value: f }))} />
        )}
      </Box>
    </FocusScope>
  );
}

function FileTree() {
  const root = useFocusScope({
    keybindings: ({ nextShallow, prevShallow }) => ({
      j: nextShallow, k: prevShallow
    })
  });

  return (
    <FocusScope handle={root}>
      <DirItem name="src" files={['index.ts', 'utils.ts', 'types.ts']} />
      <DirItem name="tests" files={['unit.test.ts', 'e2e.test.ts']} />
    </FocusScope>
  );
}
```

<Terminal>
  <FileTreeExample />
</Terminal>
