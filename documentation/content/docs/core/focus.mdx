---
title: Focus
description: API reference for the focus system
---

import { TypeTable } from 'fumadocs-ui/components/type-table';
import { Callout } from 'fumadocs-ui/components/callout';
import { Terminal } from '@/components/terminal';
import NavigableMenuExample from '@/components/examples/focus/navigable-menu';
import ControlledFocusExample from '@/components/examples/focus/controlled-focus';
import FileTreeExample from '@/components/examples/focus/file-tree';

The focus system provides components and hooks for managing keyboard navigation.

`FocusGroup` is the scoping primitive — it creates a navigable region and provides context for its children. Navigation between children is explicit: pass a `keybindings` function that receives `next`, `prev`, and `escape` helpers and returns a key map. This makes nested layouts composable, since each group only handles the keys you assign it.

Components that are themselves focus targets — items in a list, tabs, form fields — call `useFocusNode()` to register in the tree. Components that need to reflect focus state without being navigable themselves call `useFocus()`. The two hooks are intentionally separate: one creates a node, the other reads one.

```tsx title="Navigable Menu"
import { FocusGroup, useFocusNode } from 'giggles';

function Menu() {
  return (
    <FocusGroup keybindings={({ next, prev }) => ({ j: next, k: prev, down: next, up: prev })}>
      <MenuItem label="New File" />
      <MenuItem label="Open File" />
      <MenuItem label="Save" />
    </FocusGroup>
  );
}

function MenuItem({ label }: { label: string }) {
  const focus = useFocusNode();
  return (
    <Text color={focus.focused ? 'green' : 'white'}>
      {focus.focused ? '> ' : '  '}
      {label}
    </Text>
  );
}
```

<Terminal>
  <NavigableMenuExample />
</Terminal>

## API Reference

### useFocus()

Returns the focus state of the nearest `FocusGroup` ancestor. Does not create a node in the focus tree. Use this for visual indicators — borders, highlights — on container components.

```ts title="Type Signature"
function useFocus(): FocusHandle
```

**Returns:** `FocusHandle`

<TypeTable
  type={{
    id: {
      description: 'ID of the containing FocusGroup node',
      type: 'string',
      required: true,
    },
    focused: {
      description: 'Whether this group or any descendant currently has focus',
      type: 'boolean',
      required: true,
    },
    focus: {
      description: 'Programmatically focus this group',
      type: '() => void',
      required: true,
    },
  }}
/>

When called outside any `FocusGroup`, returns `{ focused: false, focus: () => {} }`.

### useFocusNode()

Registers a component as a node in the focus tree and returns its focus handle. Use this for components that are themselves focusable targets: list items, tabs, form fields.

```ts title="Type Signature"
function useFocusNode(id?: string): FocusHandle
```

**Parameters:**

<TypeTable
  type={{
    id: {
      description: 'Optional logical ID for declarative focus control via FocusGroup value prop',
      type: 'string',
    },
  }}
/>

**Returns:** `FocusHandle`

<TypeTable
  type={{
    id: {
      description: 'Unique identifier for this focus node',
      type: 'string',
      required: true,
    },
    focused: {
      description: 'Whether this node or any descendant currently has focus',
      type: 'boolean',
      required: true,
    },
    focus: {
      description: 'Programmatically focus this node',
      type: '() => void',
      required: true,
    },
  }}
/>

The `FocusHandle` type can be imported for typing component props:

```tsx title="Typing Props"
import type { FocusHandle } from 'giggles';

function MyComponent({ focus }: { focus: FocusHandle }) {
  return <Text color={focus.focused ? 'green' : 'white'}>Item</Text>;
}
```

### FocusGroup

Creates a focus scope. Children that call `useFocusNode()` register as nodes within this group. Pass a `keybindings` function to control navigation between them.

<TypeTable
  type={{
    keybindings: {
      description: 'Keybindings active while this group or any descendant has focus. Pass a function to receive next/prev/escape navigation helpers.',
      type: 'Keybindings | ((helpers: FocusGroupHelpers) => Keybindings)',
    },
    wrap: {
      description: 'Whether next/prev wrap around at the ends',
      type: 'boolean',
      default: 'true',
    },
    value: {
      description: 'Controlled focus — logical ID of the child that should be focused. Children must pass a matching id to useFocusNode().',
      type: 'string',
    },
    children: {
      description: 'Focusable child components',
      type: 'React.ReactNode',
      required: true,
    },
  }}
/>

#### FocusGroupHelpers

<TypeTable
  type={{
    next: {
      description: 'Focus the next sibling within this group. Wraps by default.',
      type: '() => void',
      required: true,
    },
    prev: {
      description: 'Focus the previous sibling within this group. Wraps by default.',
      type: '() => void',
      required: true,
    },
    escape: {
      description: 'Yield focus to this group\'s own node, allowing the parent group to navigate away from it.',
      type: '() => void',
      required: true,
    },
  }}
/>

### useFocusState()

Returns a state tuple for controlling focus declaratively.

```ts title="Type Signature"
function useFocusState<T extends string>(initial: T): [T, (value: T) => void]
```

<TypeTable
  type={{
    initial: {
      description: 'Initial focused value',
      type: 'T extends string',
      required: true,
    },
  }}
/>

**Returns:** A tuple `[currentValue, setValue]` similar to `useState`.

## Examples

### Controlled focus

Use the `value` prop with the `id` parameter on `useFocusNode` to control focus declaratively:

```tsx title="Controlled Form"
import { FocusGroup, useFocusNode } from 'giggles';

function Form() {
  const [field, setField] = useState('name');

  const advance = () =>
    setField((f) => (f === 'name' ? 'email' : f === 'email' ? 'submit' : 'name'));

  return (
    <FocusGroup value={field} keybindings={{ n: advance }}>
      <Field id="name" label="Name" />
      <Field id="email" label="Email" />
      <Field id="submit" label="Submit" />
    </FocusGroup>
  );
}

function Field({ id, label }: { id: string; label: string }) {
  const focus = useFocusNode(id);
  return <Text color={focus.focused ? 'green' : 'white'}>{label}</Text>;
}
```

<Terminal>
  <ControlledFocusExample />
</Terminal>

<Callout type="warn">
  Each child within a `FocusGroup` using `value` must pass a unique `id` to `useFocusNode`. Duplicate IDs will throw a `GigglesError`.
</Callout>

### File tree

A collapsible file tree with two levels of navigation. The root group uses `j`/`k` to move between top-level entries. Each directory is its own `FocusGroup` — `l` expands it, then `j` enters it. When DirItem's own node is focused and `next` is called, the framework focuses the first child of the group, descending to the first leaf. Once inside, `j`/`k` on the inner group shadow the root group's bindings. `h` collapses the directory, unmounting the inner group and automatically returning focus to the directory node. `useFocus` on the directory row stays green as long as any descendant has focus.

```tsx title="File Tree"
import { FocusGroup, useFocus, useFocusNode, useTheme } from 'giggles';

function FileItem({ name, indent = false }: { name: string; indent?: boolean }) {
  const focus = useFocusNode();
  return (
    <Text color={focus.focused ? 'green' : 'white'}>
      {indent ? '    ' : '  '}
      {focus.focused ? '> ' : '  '}
      {name}
    </Text>
  );
}

function DirContent({ name, files, open, onClose }: { name: string; files: string[]; open: boolean; onClose: () => void }) {
  const { focused } = useFocus();
  const { indicator, indicatorOpen } = useTheme();
  return (
    <Box flexDirection="column">
      <Text color={focused ? 'green' : 'white'}>
        {'  '}{open ? indicatorOpen : indicator} {name}/
      </Text>
      {open && (
        <FocusGroup wrap={false} keybindings={({ next, prev }) => ({ j: next, k: prev, h: onClose })}>
          {files.map((f) => <FileItem key={f} name={f} indent />)}
        </FocusGroup>
      )}
    </Box>
  );
}

function DirItem({ name, files }: { name: string; files: string[] }) {
  const [open, setOpen] = useState(false);
  return (
    <FocusGroup
      keybindings={({ next }) =>
        open
          ? { j: next, h: () => setOpen(false) }
          : { l: () => setOpen(true), enter: () => setOpen(true) }
      }
    >
      <DirContent name={name} files={files} open={open} onClose={() => setOpen(false)} />
    </FocusGroup>
  );
}

function FileTree() {
  return (
    <FocusGroup keybindings={({ next, prev }) => ({ j: next, k: prev })}>
      <DirItem name="src" files={['index.ts', 'utils.ts', 'types.ts']} />
      <DirItem name="tests" files={['unit.test.ts', 'e2e.test.ts']} />
      <FileItem name="package.json" />
    </FocusGroup>
  );
}
```

<Terminal>
  <FileTreeExample />
</Terminal>
