---
title: API Reference
description: API reference for the screen router
---

import { TypeTable } from 'fumadocs-ui/components/type-table';
import { Callout } from 'fumadocs-ui/components/callout';

### Router

Manages a stack of screens. Only the top screen is visible; others remain mounted but hidden.

<TypeTable
  type={{
    initialScreen: {
      description: 'Name of the screen to display first. Must match a Screen child.',
      type: 'string',
      required: true,
    },
    initialParams: {
      description: 'Params to pass to the initial screen',
      type: 'Record<string, unknown>',
    },
    restoreFocus: {
      description: 'Restore the previously focused element when returning to a screen. When false, always focuses the first child.',
      type: 'boolean',
      default: 'true',
    },
    children: {
      description: 'Screen components defining available routes',
      type: 'React.ReactNode',
      required: true,
    },
  }}
/>

<Callout type="warn">
  Throws a `GigglesError` if `initialScreen` does not match any registered Screen name.
</Callout>

### Screen

Declarative route definition. Renders nothing â€” used by Router to register screens.

<TypeTable
  type={{
    name: {
      description: 'Unique name for this screen',
      type: 'string',
      required: true,
    },
    component: {
      description: 'Component to render when this screen is active',
      type: 'React.ComponentType',
      required: true,
    },
  }}
/>

### useNavigation()

Returns navigation methods and current route state. Must be used within a Router.

```ts title="Type Signature"
function useNavigation(): NavigationContextValue
```

<TypeTable
  type={{
    currentRoute: {
      description: 'The current screen route (name, params, id)',
      type: 'ScreenRoute',
      required: true,
    },
    active: {
      description: 'Whether this screen is the top of the stack',
      type: 'boolean',
      required: true,
    },
    canGoBack: {
      description: 'Whether the stack has more than one screen',
      type: 'boolean',
      required: true,
    },
    push: {
      description: 'Push a new screen onto the stack',
      type: '(name: string, params?: Record<string, unknown>) => void',
      required: true,
    },
    pop: {
      description: 'Remove the top screen from the stack. No-op if only one screen remains.',
      type: '() => void',
      required: true,
    },
    replace: {
      description: 'Replace the top screen with a new one',
      type: '(name: string, params?: Record<string, unknown>) => void',
      required: true,
    },
    reset: {
      description: 'Clear the stack and set a single screen',
      type: '(name: string, params?: Record<string, unknown>) => void',
      required: true,
    },
  }}
/>

<Callout type="warn">
  `push`, `replace`, and `reset` throw a `GigglesError` if the screen name is not registered.
</Callout>

#### ScreenRoute

<TypeTable
  type={{
    id: {
      description: 'Unique identifier for this stack entry',
      type: 'number',
      required: true,
    },
    name: {
      description: 'The screen name as registered with Screen',
      type: 'string',
      required: true,
    },
    params: {
      description: 'Params passed when the screen was pushed',
      type: 'Record<string, unknown>',
    },
  }}
/>
