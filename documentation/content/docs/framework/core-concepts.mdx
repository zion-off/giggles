---
title: Core Concepts
description: Understanding how giggles manages focus and input
---

giggles is built around three systems that work together: the **focus tree**, the **input router**, and the **screen router**. Understanding these concepts helps you build more complex applications.

## GigglesProvider

`GigglesProvider` wraps your entire application and sets up the focus, input, and theme systems. Every giggles app starts with this provider:

```tsx
import { GigglesProvider } from 'giggles';

function App() {
  return (
    <GigglesProvider>
      {/* your app */}
    </GigglesProvider>
  );
}
```

## The Focus Tree

The focus system tracks which component is currently active. Components organize themselves into a tree structure that mirrors your UI hierarchy.

### Registering as focusable

Call `useFocusNode()` to make a component focusable:

```tsx
const focus = useFocusNode();
// focus.focused — whether this component has focus
// focus.focus() — programmatically move focus here
```

When your component unmounts, focus automatically moves to its parent. The first component to register receives focus automatically, so your app always has an active component.

### Reading parent focus

Container components that need to show visual indicators (like borders) but aren't themselves focusable can use `useFocus()` to read their ancestor group's focus state:

```tsx
const focus = useFocus();
// focus.focused is true when any descendant has focus
```

### FocusGroup

`FocusGroup` creates a navigable region with explicit key mappings. You define which keys move between children:

```tsx
<FocusGroup keybindings={({ next, prev }) => ({ 
  j: next, 
  k: prev,
  escape: () => {} // custom handler
})}>
  <MenuItem />
  <MenuItem />
  <MenuItem />
</FocusGroup>
```

`next` and `prev` navigate between siblings. When a component has nested `FocusGroup` children, calling `next` descends into the first leaf automatically — so navigation feels natural without manual coordination.

Nested groups only respond to keys you assign them, preventing conflicts. A file tree might use `j`/`k` at the top level and `h`/`l` for expand/collapse, with both working correctly because each group controls its own bindings.

## Input Routing

When a key is pressed, giggles searches for a matching handler by walking up the focus tree from the currently focused component toward the root.

### Priority order

1. **Capture mode** — if enabled and the key is not in `passthrough`, intercepts immediately
2. **Focused component's bindings** — checked next (or first if no capture)
3. **Parent component's bindings** — then grandparent, and so on
4. **Focus trap** — stops input from reaching anything outside the trap boundary
5. **Mounted bindings** — global shortcuts registered with `when: 'mounted'`, checked last

This priority order means:
- Capture mode truly captures — navigation keys become text input
- Keys in `passthrough` check named bindings instead
- Deeply nested components take precedence over their parents
- Modals can prevent keys from reaching background components
- Global shortcuts work regardless of which component has focus

### Multiple keybindings

You can call `useKeybindings` multiple times in the same component. All bindings are active simultaneously, and later calls override earlier ones for duplicate keys:

```tsx
// Base navigation
useKeybindings(focus, {
  j: moveDown,
  k: moveUp,
});

// Search mode — adds capture when active
useKeybindings(
  focus,
  { escape: exitSearch },
  { capture: searchMode, onKeypress: handleInput }
);
```

This lets you separate concerns naturally instead of managing one big conditional keybinding object.

## The Screen Router

The router manages a stack of screens. Operations map to stack manipulation:

- `push(name, params)` — open a new screen on top
- `pop()` — close the current screen, return to previous
- `replace(name, params)` — swap the current screen
- `reset(name, params)` — clear the stack and show this screen

### Screen persistence

All screens in the stack stay mounted but hidden. When you navigate back, the previous screen's state is exactly as you left it — no re-initialization or state loss. This makes back navigation instant and predictable.

Each screen maintains its own focus state. When you push a new screen, the current focus position is saved. Popping the screen restores focus to where it was before.

### Accessing navigation

Use `useNavigation()` inside screen components to access navigation functions:

```tsx
function DetailScreen() {
  const { pop, push, currentRoute } = useNavigation();
  
  return (
    <Box>
      <Text>Viewing {currentRoute.params.id}</Text>
    </Box>
  );
}
```
