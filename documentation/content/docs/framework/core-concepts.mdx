---
title: Core Concepts
description: Understanding how giggles manages focus and input
---

giggles is built around three systems that work together: the **focus tree**, the **input router**, and the **screen router**. Understanding these concepts helps you build more complex applications.

## GigglesProvider

`GigglesProvider` wraps your entire application and sets up the focus, input, and theme systems. Every giggles app starts with this provider:

```tsx title="Setup"
import { GigglesProvider } from 'giggles';

function App() {
  return (
    <GigglesProvider>
      {/* your app */}
    </GigglesProvider>
  );
}
```

## The Focus Tree

The focus system tracks which component is currently active. Components organize themselves into a tree structure that mirrors your UI hierarchy.

### Registering as focusable

Call `useFocusNode()` to make a component a focusable target:

```tsx title="useFocusNode"
const focus = useFocusNode();
// focus.hasFocus — whether this component has focus
```

When your component unmounts, focus automatically moves to its nearest ancestor. The first component to register receives focus automatically, so your app always has an active component.

### Creating navigable regions

`useFocusScope` creates a scope — a grouping of focusable children with explicit navigation keybindings. Wrap children with `<FocusScope>` to set the parent context:

```tsx title="useFocusScope"
function Menu() {
  const scope = useFocusScope({
    keybindings: ({ next, prev }) => ({
      j: next,
      k: prev,
    })
  });

  return (
    <FocusScope handle={scope}>
      <MenuItem />
      <MenuItem />
      <MenuItem />
    </FocusScope>
  );
}
```

`next` and `prev` navigate between children. By default they descend to the first leaf automatically, so navigation feels natural without manual coordination.

The scope handle exposes `hasFocus` — true whenever any descendant has focus. Use it for container-level visual indicators like borders:

```tsx title="Focus indicator"
<Box borderColor={scope.hasFocus ? 'green' : undefined}>
  <FocusScope handle={scope}>
    {children}
  </FocusScope>
</Box>
```

Nested scopes only respond to keys you assign them, preventing conflicts. A file tree might use `j`/`k` at the top level and `h`/`l` for expand/collapse, with both working correctly because each scope controls its own keybindings.

### Passive scopes

When two scopes at different nesting levels use the same keys, the innermost scope wins because input dispatch walks from the focused node upward. To voluntarily yield control back to the parent, call `escape()` from your keybindings:

```tsx title="Passive mode"
const scope = useFocusScope({
  keybindings: ({ next, prev, escape }) => ({
    j: next,
    k: prev,
    h: escape  // yield to parent — its j/k now fire
  })
});
```

After `escape()`, the scope enters passive mode: it is skipped during input dispatch until focus moves elsewhere. `scope.isPassive` lets you reflect this in the UI — for example, switching a border from green to yellow while the user navigates at the parent level.

```tsx title="Passive indicator"
<Box borderColor={scope.isPassive ? 'yellow' : scope.hasFocus ? 'green' : undefined}>
```

Passive mode clears automatically when focus moves to a different scope.

## Input Routing

When a key is pressed, giggles searches for a matching handler by walking up the focus tree from the currently focused component toward the root.

### Priority order

1. **Focused component's named bindings** — checked first, always
2. **Parent component's bindings** — then grandparent, and so on; unhandled keys bubble up naturally
3. **Passive scopes** — skipped entirely during the walk
4. **Focus trap** — stops the walk; nothing outside the trap is reachable
5. **Capture mode** — fires last, only if no named binding matched anywhere in the path

This priority order means:
- Named bindings always win — even over capture mode at the same node
- Keys in `passthrough` skip `onKeypress` and bubble to parent scopes
- Deeply nested components take precedence over their parents
- Passive scopes are transparent to input
- Modals can prevent keys from reaching background components
- App-level shortcuts work by registering them on a root scope — they receive any key that no child handles

### Multiple keybindings

You can call `useKeybindings` multiple times in the same component. All bindings are active simultaneously, and later calls override earlier ones for duplicate keys:

```tsx title="Multiple keybindings"
// Base navigation
useKeybindings(focus, {
  j: moveDown,
  k: moveUp,
});

// Search mode — adds capture when active
useKeybindings(
  focus,
  { escape: exitSearch },
  { capture: searchMode, onKeypress: handleInput }
);
```

This lets you separate concerns naturally instead of managing one big conditional keybinding object.

## The Screen Router

The router manages a stack of screens. Operations map to stack manipulation:

- `push(name, params)` — open a new screen on top
- `pop()` — close the current screen, return to previous
- `replace(name, params)` — swap the current screen
- `reset(name, params)` — clear the stack and show this screen

### Screen persistence

All screens in the stack stay mounted but hidden. When you navigate back, the previous screen's state is exactly as you left it — no re-initialization or state loss. This makes back navigation instant and predictable.

Each screen maintains its own focus state. When you push a new screen, the current focus position is saved. Popping the screen restores focus to where it was before.

### Accessing navigation

Use `useNavigation()` inside screen components to access navigation functions:

```tsx title="useNavigation"
function DetailScreen() {
  const { pop, push, currentRoute } = useNavigation();

  return (
    <Box>
      <Text>Viewing {currentRoute.params.id}</Text>
    </Box>
  );
}
```
