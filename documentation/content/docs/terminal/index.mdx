---
title: Terminal
description: API reference for terminal utilities
---

import { TypeTable } from 'fumadocs-ui/components/type-table';

Hooks and components for reactive terminal dimensions, OS-level focus detection, and handing terminal control to external programs.

These are imported from `giggles/terminal` — a separate entry point not included in the main bundle.

```tsx title="Import"
import { useTerminalSize, useTerminalFocus, useShellOut, useSpawn } from 'giggles/terminal';
```

## API Reference

### useTerminalSize()

Returns reactive terminal dimensions that update on resize.

```ts title="Type Signature"
function useTerminalSize(): TerminalSize
```

**Returns:** `TerminalSize`

<TypeTable
  type={{
    rows: {
      description: 'Number of rows in the terminal',
      type: 'number',
      required: true,
    },
    columns: {
      description: 'Number of columns in the terminal',
      type: 'number',
      required: true,
    },
  }}
/>

### useTerminalFocus()

Detects when the terminal window gains or loses OS-level focus.

```ts title="Type Signature"
function useTerminalFocus(callback: (focused: boolean) => void): void
```

Opts into ANSI focus reporting (`\x1b[?1004h`). The terminal emits a sequence when the user switches to another app and back. Not all terminal emulators support this — test for your target environment.

<TypeTable
  type={{
    callback: {
      description: 'Called with true when the terminal gains focus, false when it loses focus',
      type: '(focused: boolean) => void',
      required: true,
    },
  }}
/>

### useShellOut()

Hands terminal control to an external program and reclaims it when the process exits.

```ts title="Type Signature"
function useShellOut(): { run: (command: string) => Promise<{ exitCode: number }> }
```

`run()` handles the full sequence: leaves the alternate screen, releases stdin/stdout to the child process with `stdio: 'inherit'`, waits for exit, then reclaims control and repaints. Getting this sequence wrong leaves the terminal in a broken state — use this instead of spawning processes manually.

`run()` never throws on non-zero exit codes. Check `exitCode` in the result if you need to act on failure.

<TypeTable
  type={{
    run: {
      description: 'Runs a shell command with full terminal control. Returns the exit code when the process exits.',
      type: '(command: string) => Promise<{ exitCode: number }>',
      required: true,
    },
  }}
/>

### useSpawn()

Spawns a child process and streams its output into React state while the TUI stays live.

```ts title="Type Signature"
function useSpawn(): SpawnHandle
```

Unlike `useShellOut`, the TUI keeps rendering while the process runs — output arrives incrementally via `output`. Call `run()` to spawn a process; calling it again while a process is already running kills the previous one first. The process is killed automatically on unmount.

**Returns:** `SpawnHandle`

<TypeTable
  type={{
    run: {
      description: 'Spawns a process. Kills any currently running process before starting the new one.',
      type: '(command: string, args?: string[], options?: SpawnOptions) => void',
      required: true,
    },
    output: {
      description: 'Ordered list of lines received from the process. Cleared each time run() is called.',
      type: 'SpawnOutputLine[]',
      required: true,
    },
    running: {
      description: 'True while the process is alive. Becomes false once the process exits, errors, or is killed.',
      type: 'boolean',
      required: true,
    },
    exitCode: {
      description: 'The exit code once the process has exited. Null while running or if the process was killed by a signal.',
      type: 'number | null',
      required: true,
    },
    error: {
      description: 'Set if the process failed to start or emitted a Node.js error event (e.g. ENOENT). Cleared on each run() call.',
      type: 'Error | null',
      required: true,
    },
    kill: {
      description: 'Sends SIGTERM to the process and immediately sets running to false.',
      type: '() => void',
      required: true,
    },
  }}
/>

**`SpawnOutputLine`**

<TypeTable
  type={{
    type: {
      description: 'Which stream the data came from.',
      type: "'stdout' | 'stderr'",
      required: true,
    },
    data: {
      description: 'Raw string chunk as received from the stream. May contain partial lines or ANSI escape codes.',
      type: 'string',
      required: true,
    },
  }}
/>

**Options**

All options from Node's `child_process.spawn` are accepted, plus:

<TypeTable
  type={{
    pty: {
      description: 'Injects FORCE_COLOR=1 and TERM=xterm-256color into the child environment so tools that detect isTTY emit ANSI color codes.',
      type: 'boolean',
      default: 'false',
    },
  }}
/>

## Examples

### Responsive layout

```tsx title="Responsive Sidebar"
import { useTerminalSize } from 'giggles/terminal';
import { Box } from 'ink';

function App() {
  const { columns } = useTerminalSize();

  return (
    <Box>
      {columns > 80 && <Sidebar />}
      <MainContent />
    </Box>
  );
}
```

### Pause on blur

```tsx title="Pause on Blur"
import { useTerminalFocus } from 'giggles/terminal';
import { useState } from 'react';
import { Text } from 'ink';

function Timer() {
  const [paused, setPaused] = useState(false);

  useTerminalFocus((focused) => {
    setPaused(!focused);
  });

  return <Text>{paused ? 'Paused' : 'Running'}</Text>;
}
```

### Stream command output

```tsx title="Docker Logs"
import { useFocusScope, useKeybindings } from 'giggles';
import { useSpawn } from 'giggles/terminal';
import { Box, Text } from 'ink';

function DockerLogs({ container }: { container: string }) {
  const scope = useFocusScope();
  const { output, running, error, run, kill } = useSpawn();

  useKeybindings(scope, {
    r: () => run('docker', ['logs', '-f', container], { pty: true }),
    k: kill,
  });

  return (
    <Box flexDirection="column">
      {error && <Text color="red">{error.message}</Text>}
      {output.map((line, i) => (
        <Text key={i}>{line.data}</Text>
      ))}
      {running && <Text dimColor>Tailing logs… (k to stop)</Text>}
      {!running && !error && <Text dimColor>r to tail logs</Text>}
    </Box>
  );
}
```

### Open $EDITOR

```tsx title="Edit a File"
import { useFocusScope, useKeybindings } from 'giggles';
import { useShellOut } from 'giggles/terminal';
import { Text } from 'ink';

function FileViewer({ path }: { path: string }) {
  const scope = useFocusScope();
  const shell = useShellOut();

  useKeybindings(scope, {
    e: async () => {
      await shell.run(`${process.env.EDITOR ?? 'vim'} ${path}`);
    },
  });

  return <Text dimColor>Press e to edit {path}</Text>;
}
```

